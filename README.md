<!-- Se√ß√µes do portf√≥lio -->
<div id="topo">
    <h1>Bem-vindo ao Meu Portf√≥lio dos Projetos API's (Aprendizagem de Projetos Integradores) by FATEC S√£o Jos√© dos Campos - Jessen Vidal</h1>
</div>

<h2><a href ="https://github.com/LeoAdlerr/PortfolioApis/blob/main/english/README.md"> English Portfolio </a><h2>

## Leonardo Adler da Silva

Ol√°, sou **Leonardo Adler da Silva**, estudante de Banco de Dados na Fatec FATEC S√£o Jos√© dos Campos - Jessen Vidal. Ao longo da minha jornada acad√™mica, tive a oportunidade de trabalhar com metodologias √°geis e diversas tecnologias, resultando em projetos empolgantes que compartilho abaixo. 


### üöÄ Projetos por Semestre

<table style="width:100%; border-collapse: collapse; margin-top: 20px;">
    <thead>
        <tr>
            <th style="border: 1px solid #ccc; padding: 10px; text-align: left;">Projeto</th>
            <th style="border: 1px solid #ccc; padding: 10px; text-align: left;">Descri√ß√£o</th>
            <th style="border: 1px solid #ccc; padding: 10px; text-align: left;">Tecnologias</th>
            <th style="border: 1px solid #ccc; padding: 10px; text-align: left;">Cliente</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><a href="#portfolio1Covid">1¬∫ Semestre Python (Fatec/Interno)</a></td>
            <td>Desenvolvimento de um programa que apresenta estat√≠sticas da Covid-19 em SP, ajudando a popula√ß√£o a entender a pandemia atrav√©s de gr√°ficos e dados acess√≠veis.</td>
            <td>Python</td>
            <td>Fatec</td>
        </tr>
        <tr>
	    <td><a href="#portfolio2DomRock">2¬∫ Semestre Java Desktop (DomRock)</a></td>
	    <td>Desenvolvimento de uma solu√ß√£o para gest√£o da ativa√ß√£o de clientes na plataforma Dom Rock, permitindo a entrada de dados sobre par√¢metros e vari√°veis de cada cliente, com modelagem de dados para futuras
		    integra√ß√µes e gera√ß√£o de relat√≥rios.</td>
	    <td>Java, Swing, SqlServer</td>
	    <td>DomRock</td>
	</tr>
        <tr>
	    <td><a href="#portfolio3IACIT">3¬∫ Semestre Java - SpringBoot (IACIT)</a></td>
	    <td>Desenvolvimento de um sistema para automatizar a importa√ß√£o e o armazenamento de dados meteorol√≥gicos, permitindo a gera√ß√£o de relat√≥rios customizados e reduzindo a perda de tempo e recursos na 
		    consultoria meteorol√≥gica.</td>
	    <td>Java, SpringBoot, PostgreSQL</td>
	    <td>IACIT</td>
	</tr>
       <tr>
	    <td><a href="#portfolio4Jaia">4¬∫ Semestre Vue.JS - SpringBoot (JAIA)</a></td>
	    <td>Desenvolvimento de um sistema para controlar anomalias em Laudos de Inspe√ß√£o Predial, gerenciando manuten√ß√µes preventivas e corretivas para garantir a seguran√ßa e qualidade dos patrim√¥nios.</td>
	    <td>Vue.js, Java, SpringBoot, Oracle Cloud/Database, Docker</td>
	    <td>JAIA</td>
	</tr>
        <tr>
	    <td><a href="#portfolio5Tecsus">5¬∫ Semestre Node.js - PowerBi (TECSUS)</a></td>
	    <td>Desenvolvimento de um dashboard web para an√°lise de faturas de energia e √°gua, com o objetivo de otimizar contratos e reduzir custos para empresas clientes da TecSUS.</td>
	    <td>Node.js, Vue.js Power BI, MySQL, Docker/Docker Compose, Railway</td>
	    <td>TECSUS</td>
	</tr>
        <tr>
		<td><a href="#portfolio6SPCGrafeno">6¬∫ Semestre Intelig√™ncia Artificial - Node.js (SPC Grafeno)</a></td>
		    <td>Desenvolvimento de produtos financeiros inovadores utilizando aprendizado de m√°quina para analisar a confiabilidade de endossantes e prever tend√™ncias de ativos financeiros.</td>
		    <td>Node.js, Vue.js, Machine Learning, IA/TensorFlow, PostgreSQL, Railway, Docker/Docker Compose</td>
		<td>SPC Grafeno</td>
	</tr>
    </tbody>
</table>

#### Feito com entusiasmo por Leonardo Adler da Silva

<br>

<div id="portfolio1Covid">
	<h2> Projeto API - Estat√≠sticas Covid-19 (Fatec, 2021-2) </h2>
</div>

[Link para o Reposit√≥rio](https://github.com/LeoAdlerr/Projeto-Integrador-2021-2-Grupo3)

### Resumo do Projeto
Este projeto marcou minha primeira experi√™ncia com programa√ß√£o e an√°lise de dados. Apesar da minha falta de experi√™ncia inicial, consegui desenvolver uma aplica√ß√£o competente que fornece e informa estat√≠sticas sobre a Covid-19 em S√£o Paulo atrav√©s de gr√°ficos, facilitando a compreens√£o dos dados. Com uma interface simples no terminal, o projeto foi desenvolvido com foco em acessibilidade e precis√£o na an√°lise dos dados.

### Relev√¢ncia do Projeto
Este projeto teve um impacto social significativo, ajudando a popula√ß√£o a entender a evolu√ß√£o da pandemia. Atrav√©s dos dados de casos confirmados e √≥bitos, a aplica√ß√£o incentiva uma an√°lise cr√≠tica sobre as medidas tomadas no estado de SP, contribuindo para uma vis√£o mais informada sobre a pandemia.

### Objetivos
O objetivo principal foi criar uma ferramenta acess√≠vel que permitisse ao usu√°rio visualizar gr√°ficos sobre dados de √≥bitos e casos confirmados de Covid-19, filtrados pela regi√£o e data de interesse. A aplica√ß√£o foi desenvolvida para ser direta e intuitiva, facilitando o acesso e an√°lise das informa√ß√µes.

---

### Tecnologias Utilizadas
- **Python:** Para desenvolvimento r√°pido e intuitivo de an√°lise e visualiza√ß√£o de dados.
- **Pandas:** Para manipula√ß√£o eficiente de grandes volumes de dados.
- **Matplotlib:** Para visualiza√ß√£o de dados com gr√°ficos interativos e personaliz√°veis.

---

### Minhas Contribui√ß√µes
Durante o desenvolvimento, desempenhei um papel ativo nas seguintes atividades:

- **Coleta e Manipula√ß√£o de Dados:** Extra√≠ e filtrei dados relevantes do CSV usando Pandas, concentrando informa√ß√µes no estado de S√£o Paulo.
- **Cria√ß√£o de Gr√°ficos:** Utilizei Matplotlib para gerar visualiza√ß√µes claras e intuitivas, promovendo uma compreens√£o acess√≠vel dos dados.
- **Interatividade do Programa:** Implementei um sistema de menus, tornando o programa din√¢mico e ajust√°vel √†s necessidades do usu√°rio.
- **Lideran√ßa como Scrum Master:** Atuei como Scrum Master, onde aprendi a conduzir reuni√µes e a coordenar a equipe para atingir os objetivos do projeto.

---

### Soft Skills Desenvolvidas
- **Resili√™ncia:** Como iniciante em programa√ß√£o, aprendi a resolver problemas e a lidar com desafios t√©cnicos, persistindo at√© superar obst√°culos.
- **Autonomia e Autodidatismo:** Fui o membro com maior entrega no projeto, e aprendi a maior parte das tecnologias utilizadas de forma aut√¥noma.
- **Comunica√ß√£o e Gest√£o de Equipe:** Minha experi√™ncia como Scrum Master permitiu-me melhorar minhas habilidades de comunica√ß√£o, organizando o fluxo de trabalho e facilitando o engajamento da equipe.

---

### Aprendizados Efetivos
- **Uso de bibliotecas em Python:** Compreendi a import√¢ncia de Pandas e Matplotlib para manipula√ß√£o e visualiza√ß√£o de dados.
- **Estruturas de controle:** Desenvolvi a habilidade de construir uma interface interativa utilizando la√ßos e condicionais.
- **An√°lise de dados:** Transformei dados brutos em informa√ß√µes significativas, criando insights relevantes para o p√∫blico.


<br><br>


<!-- Links para navega√ß√£o -->
<a href="#topo">Voltar ao topo</a>

<br><br>

<div id="portfolio2DomRock">
	<h2> Em 2022-1 foi trabalhado um projeto API com o parceiro acad√™mico DomRock </h2> 
</div>
 
# Projeto de Gest√£o de Ativa√ß√£o de Clientes - Dom Rock

* [Link para o Reposit√≥rio](https://github.com/DatatechOffice/datatech_api)

## Vis√£o e Objetivo do Projeto
O desafio consiste na gest√£o de ativa√ß√£o de clientes na plataforma Dom Rock. Precisamos de uma solu√ß√£o que seja orientada a entrada de dados de par√¢metros e vari√°veis de cada cliente para alocar recursos na plataforma Dom Rock, entrada de dados e estimativa de consumo de recursos (baseado em volume de dados de cliente, quantidade de usu√°rios e outros) e gere relat√≥rios e consultas, mas, principalmente, tenha a base de dados modelada adequadamente para futuras integra√ß√µes com outros sistemas. Para realizar o desafio, foi necess√°ria a cria√ß√£o de interfaces para cada etapa do programa visando facilitar a ativa√ß√£o delas e dos cadastros posteriormente, al√©m de tornar o processo vis√≠vel aos clientes.

## Tecnologias Utilizadas no Projeto
<ul>
  <li><strong>Java:</strong> 
    <br>A linguagem de programa√ß√£o utilizada com as l√≥gicas para inser√ß√£o, selecionar, deletar e excluir. Assim conectando o banco de dados √† aplica√ß√£o Desktop.
  </li>
  <li><strong>SqlServer:</strong> 
    <br>Foi utilizado um banco na nuvem Azure (SqlServer) onde os dados de login e dos pedidos dos clientes foram armazenados.
  </li>
  <li><strong>JavaSwing:</strong> 
    <br>Todo o visual e design da aplica√ß√£o foi feito usando essa tecnologia, desde a tela de login at√© a tela gold.
  </li>
  <li><strong>Maven:</strong> 
    <br>Utilizado para versionar e enviar o c√≥digo no Git, assim facilitando a todos os desenvolvedores e usu√°rios a utilizarem o c√≥digo mais atualizado no momento, principalmente na manuten√ß√£o de bibliotecas Java utilizadas, algo que durante o processo e na instala√ß√£o do c√≥digo final facilita o uso do mesmo.
  </li>
</ul>

## Contribui√ß√µes Individuais

<details>
<summary>Classes DAO de Conex√£o com BD</summary>
  <p><br>
    - Foi criada uma classe DAO chamada ConnectionManager, que cont√©m o objeto com a conex√£o para o Banco de Dados e que, por consequ√™ncia, todas as demais classes DAO ir√£o utilizar, assim n√£o sendo necess√°rio abrir uma nova conex√£o a cada evento da aplica√ß√£o:
    <br><br>
    * [classe ConnectionManager exemplo]
    <pre><code>
    public static Connection getConnection() throws SQLException {
        return DriverManager.getConnection(
            "jdbc:sqlserver://XXXXXX.DDDDDD.WWWWWW.net;databaseName=DDDD;user=SSSSSS;password=***********"
        );
    }
    </code></pre>
  </p>
</details>

<details>
<summary>Classes DAO dos Objetos</summary>
  <p><br>
    - Foi criada uma classe DAO chamada DaoCliente, onde todo evento que envolve o banco de dados na tabela/entidade Cliente √© realizado:
    <br><br>
    * [classe DaoCliente exemplo]
    <pre><code>
    public void criarCl(Cliente c1) {
        this.c1 = c1;
        Connection con = null;
        try {
            con = ConnectionManager.getConnection();
            String insert_sql = "insert into cliente (cnpj, entrega_minimas, entregas_possiveis, 
            nome_cliente, objetivo, setor, razao_social, id_solucao) values (?, ?, ?, ?, ?, ?, ?, ?)";
            PreparedStatement pst;
            pst = con.prepareStatement(insert_sql);
            pst.setObject(1, c1.getvCNPJ_Cliente());
            pst.setObject(2, c1.getvEntregaM_Cliente());
            pst.setObject(3, c1.getvEntregaP_Cliente());
            pst.setObject(4, c1.getvNome_Cliente());
            pst.setObject(5, c1.getvObjetivo_Cliente());
            pst.setObject(6, c1.getvSetor_Cliente());
            pst.setObject(7, c1.getvSocial_Cliente());
            pst.setObject(8, c1.getvId_Solucao());
            pst.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
            throw new RuntimeException("Erro ao inserir os dados!", e);
        } finally {
            try {
                if (con != null)
                    con.close();
            } catch (SQLException e) {
                e.printStackTrace();
                throw new RuntimeException("Erro ao fechar conex√£o", e);
            }
        }
    }
    </code></pre>
    Neste exemplo, o m√©todo criarCl() recebe um objeto da entidade Cliente que, por sua vez, utiliza os getters presentes nos atributos do objeto da Classe Cliente para criar um novo registro na tabela cliente com os valores especificados na view. 
  </p>
</details>

<details>
<summary>Modelagem Relacional</summary>
  <p><br>
    Foi gerada uma modelagem relacional para satisfazer a necessidade de cadastrar clientes e seus pedidos/produtos.
    <br><br>
    *[Modelagem da aplica√ß√£o]
    <br><br>
	  <img src="https://github.com/LeoAdlerr/PortfolioApis/assets/88751032/5c21e53a-fb14-468f-8472-d8ed36985de5">  
</details>

<details>
<summary>Orienta√ß√£o a Objeto e Classes que Representam Algo na Vida Real</summary>
  <p><br>
    No exemplo em quest√£o, represento a tabela cliente, que cont√©m os valores que ser√£o cadastrados pela aplica√ß√£o no banco de dados, ou seja, os valores que representam esse cliente na vida real:
    <br><br>
    //Classe
    <pre><code>
    public class Cliente {
        //Atributos
        private String vNome_Cliente;
        private String vCNPJ_Cliente;
        private String vNome_Cliente2;
        private String vCNPJ_Cliente2;
        private String vSocial_Cliente;
        private String vSetor_Cliente;
        private String vSolucao_Cliente;
        private String vObjetivo_Cliente;
        private String vEntregaM_Cliente;
        private String vEntregaP_Cliente;
        private int vId_Cliente;
        private int vId_Solucao;
        private int vId_Produto;
        private int vId_Escolha;
    }
    </code></pre>
  </p>
</details>

<br>

<h3> Resultado/Aplica√ß√£o: <h3>

  <img src="https://github.com/DatatechOffice/datatech_api/blob/main/Wireframes/Escopo.png"> 

<br>

## Aprendizado Efetivo:
### Orienta√ß√£o a Objeto:
- O principal aprendizado foi a cria√ß√£o de classes que representam as tabelas do banco de dados com os mesmos atributos; essa tarefa de mapear e representar os registros na aplica√ß√£o se tornou muito mais pr√°tica.

### MVC (Model, View, Controller):
- Com classes para representar a modelagem do BD, separadas das classes de vis√£o e conex√£o com o Banco, cada tarefa se tornou mais espec√≠fica, al√©m da aplica√ß√£o ser mais f√°cil de ser compreendida por qualquer desenvolvedor, j√° que cada parte do c√≥digo segue seu padr√£o.

### Modelagem Relacional:
- Para representar algo na vida real, foi necess√°rio criar uma modelagem relacional. Nesse projeto, isso foi imprescind√≠vel, pois os dados de uma vis√£o dependiam dos valores inseridos na anterior, inclusive com a possibilidade de uma vis√£o que poderia ter registros m√∫ltiplos da anterior para o mesmo cliente (relacionamento 1,N ou um para muitos) e outras que apenas um registro era poss√≠vel (relacionamento 1,1 ou um para um).

Os principais aprendizados incluem:
- **Import√¢ncia da Comunica√ß√£o:** A comunica√ß√£o eficaz entre os membros da equipe e stakeholders foi fundamental para o progresso do projeto e a resolu√ß√£o de problemas.

- **Adapta√ß√£o a Mudan√ßas:** A capacidade de adaptar o escopo e as prioridades do projeto em resposta a feedbacks cont√≠nuos melhorou significativamente a qualidade do produto final.

- **Desenvolvimento √Ågil:** A aplica√ß√£o de metodologias √°geis permitiu uma entrega cont√≠nua de funcionalidades, garantindo que o projeto permanecesse alinhado com as expectativas do cliente.

## üí°Considera√ß√µes Finais
O projeto foi uma experi√™ncia rica em aprendizado e colabora√ß√£o. Durante o desenvolvimento, enfrentamos desafios como a defini√ß√£o dos requisitos do sistema e a integra√ß√£o entre diferentes tecnologias, que foram superados com o esfor√ßo conjunto da equipe.

<!-- Links para navega√ß√£o -->
<a href="#topo">Voltar ao topo</a>

<br><br>

<div id="portfolio3IACIT">
	<h1> Em 2023-1 foi trabalhado um projeto API com o parceiro acad√™mico IACIT </h1>  
</div>

* [Link para o Reposit√≥rio](https://github.com/DatatechOffice/Api_Iacit)

<h4> Vis√£o e objetivo do projeto </h4>
Desenvolver um sistema web, onde fosse poss√≠vel realizar a extra√ß√£o e tratamento de dados meteorol√≥gicos atrav√©s do site INEP fornecido pelo parceiro, al√©m da persist√™ncia dos mesmos e, por fim, a visualiza√ß√£o dos dados de forma que decis√µes pudessem ser realizadas. Para tal, foram utilizados gr√°ficos e a filtragem dos dados pelo usu√°rio.

<h4>Tecnologias utilizadas no Projeto</h4>

- HTML, CSS e Bootstrap: 
  Todo o visual e design da p√°gina web foram feitos utilizando essas tecnologias, isso inclui os gr√°ficos com os dados meteorol√≥gicos, auxiliando-se das l√≥gicas do JavaScript para tal.
  
- JavaScript:
  L√≥gica das p√°ginas, seja restri√ß√µes das mesmas, preenchimentos ou a filtragem dos dados selecionados pelos usu√°rios, conectando e utilizando as APIs criadas em Java/Spring Boot.
  
- Java e Spring Boot:
  Foram feitas rotinas para persistir a base de dados meteorol√≥gicos e a cria√ß√£o das APIs REST conectando o banco de dados que cont√©m os dados meteorol√≥gicos com as p√°ginas, permitindo que os resultados sejam enviados em formato JSON para serem tratados pelo JavaScript.
  
- Python: 
  Uma rotina para capta√ß√£o dos dados em CSV fornecidos pelo cliente foi criada, permitindo a cria√ß√£o de um CSV com os valores de todos os per√≠odos agregados, possibilitando sua persist√™ncia usando Java.
  
- PostgreSQL: 
  Foi o banco de dados de prefer√™ncia da empresa contratante e utilizado para armazenar os dados meteorol√≥gicos de forma que fosse poss√≠vel utiliz√°-los num programa, al√©m de apresent√°-los em um formato e tipo que facilitassem o uso.
  
- Maven: 
  Utilizado para versionar e enviar o c√≥digo no Git, facilitando a todos os desenvolvedores e usu√°rios a utiliza√ß√£o do c√≥digo mais atualizado, principalmente na manuten√ß√£o de bibliotecas Java utilizadas.

<h4>Contribui√ß√µes Individuais</h4>

<details>
<summary>API Rest</summary>
- Usando Spring Boot, criei as APIs a serem consumidas, conectando-as ao banco SQL para buscar os dados filtrados pelo frontend. A l√≥gica foi pensada para contemplar quaisquer pesquisas feitas, al√©m do CRUD com as telas de login.

<pre><code>
@RestController
@RequestMapping("/api/v1/dados")
public class DadosController {

    @Autowired
    private DadosService dadosService;

    @GetMapping
    public List<Dados> getDados(@RequestParam(required = false) String filtro) {
        return dadosService.buscarDadosFiltrados(filtro);
    }

    @PostMapping
    public Dados criarDados(@RequestBody Dados dados) {
        return dadosService.salvarDados(dados);
    }
}
</code></pre>
</details>

<details>
<summary>Manipula√ß√£o de dados - Na persist√™ncia</summary>
- Desenvolvi scripts em Java para popular o banco com os dados vindos do CSV, garantindo que apenas uma inst√¢ncia de cada Estado fosse inserida nas tabelas.

<pre><code>
public void popularBancoComCSV(String caminhoCSV) {
    List<Estado> estados = lerCSV(caminhoCSV);
    for (Estado estado : estados) {
        if (!estadoRepository.existsById(estado.getId())) {
            estadoRepository.save(estado);
        }
    }
}
</code></pre>
</details>

<details>
<summary>Orienta√ß√£o a Objeto e classes que representam algo da vida real</summary>
- As classes foram estruturadas para representar a Radia√ß√£o Global das cidades, com atributos que refletem o hor√°rio da coleta e o valor da radia√ß√£o.

<pre><code>
@Entity
public class RadiacaoGlobal {
    @Id
    private Long id;
    private String cidade;
    private LocalDateTime horarioColeta;
    private Double valorRadiacao;

    // Getters e Setters
}
</code></pre>
</details>

<details>
<summary>Polimorfismo</summary>
- Utilizando interfaces do Hibernate, foi poss√≠vel mapear as colunas e tabelas do banco de dados com as classes que representam cada respectiva entidade.

<pre><code>
public interface RadiacaoRepository extends JpaRepository<RadiacaoGlobal, Long> {
    List<RadiacaoGlobal> findByCidade(String cidade);
}
</code></pre>
</details>

<br>

<h3> Resultado/Aplica√ß√£o: <h3>

  <img src="https://github.com/DatatechOffice/Api_Iacit/blob/Sprint4/Imagens/Wireframes/HomeCalendario.png"> 

<br>


<h4>Aprendizado Efetivo:</h4>

<summary>API's Rest:</summary>
- Foi o principal aprendizado, permitindo a cria√ß√£o de diversos tipos de aplicativos web que necessitam de mecanismos de busca ou apresenta√ß√£o de dados, como gr√°ficos. O mais importante foi entender como construir uma API REST em Spring Boot.

<summary>Protocolo HTTP e APIs REST:</summary>
- Aprendi sobre o protocolo HTTP e como ele serve como a base para a comunica√ß√£o entre o cliente e o servidor. As APIs REST utilizam os m√©todos HTTP (como GET, POST, PUT e DELETE) para realizar opera√ß√µes em recursos, permitindo a troca de dados em formato JSON. Essa interliga√ß√£o √© fundamental para a constru√ß√£o de aplicativos web que se comunicam de forma eficiente com o backend.

<summary>Orienta√ß√£o a Objeto:</summary>
- As classes da pasta Entity, com o aux√≠lio do Hibernate, representam as tabelas do banco de dados e suas correspond√™ncias com entidades da vida real.

<summary>Polimorfismo:</summary>
- A separa√ß√£o das classes em Interfaces, Services, Entities (Repositories) e Controllers facilitou a heran√ßa de funcionalidades e o controle das partes do processo, economizando linhas de c√≥digo.

<summary>Persist√™ncia/ETL:</summary>
- Utilizando orienta√ß√£o a objeto/polimorfismo, implementamos todo o processo desde o download dos CSVs com dados meteorol√≥gicos, tratamento desses arquivos e inser√ß√£o no banco, considerando a quantidade massiva de informa√ß√µes.

<summary> Soft Skills: </summary>
- O desafio mais significativo foi lidar com uma base de dados meteorol√≥gicos enorme, com mais de 2 GB, e a restri√ß√£o de usar Java e Spring Boot. Minha equipe e eu decidimos usar a biblioteca TableSaw para Java para gerenciar o volume de dados, uma tecnologia com a qual eu n√£o tinha experi√™ncia anterior. Tivemos que aprender rapidamente e resolver problemas inesperados dentro da equipe. No entanto, conseguimos entregar um projeto que permitiu a extra√ß√£o, tratamento e visualiza√ß√£o dos dados em gr√°ficos interativos com filtros personalizados. Esse projeto me deu uma excelente oportunidade de desenvolver habilidades t√©cnicas e de gest√£o de tempo, resultando em uma entrega bem-sucedida

<h4>Conclus√£o</h4>
O projeto desenvolvido em parceria com a IACIT foi uma experi√™ncia enriquecedora, proporcionando uma compreens√£o profunda sobre o uso de APIs, a manipula√ß√£o de dados e a implementa√ß√£o de solu√ß√µes web eficientes. O aprendizado do framework Spring foi crucial para estruturar as aplica√ß√µes, permitindo o desenvolvimento de sistemas robustos e escal√°veis, alinhando teoria e pr√°tica de forma significativa.

<!-- Links para navega√ß√£o -->
<a href="#topo">Voltar ao topo</a>

<br><br>

<div id="portfolio4Jaia">
	<h2>Em 2023-2 foi trabalhado um projeto API com o parceiro acad√™mico JAIA</h2> 
</div>

* [Link para o Reposit√≥rio do projeto](https://github.com/Great-Pretender/GreatPretender-API)

<h4>Vis√£o e objetivo do projeto</h4>

Um Sistema desenvolvido para controlar o estado de um im√≥vel em, com os resultados exportados num Laudo de Inspe√ß√£o Predial, al√©m de gerenciar manuten√ß√µes preventivas e corretivas de n√£o conformidades que possam estar colocando em risco um patrim√¥nio, garantindo assim a seguran√ßa, qualidade e manuten√ß√£o ou gerenciamento de riscos.

<h4>Tecnologias utilizadas no Projeto</h4>

<h5>Backend: </h5>

- **Java e Spring Boot**:
  <br><br>
  	- As API's Rest para o CRUD da aplica√ß√£o foram feitas em Spring Boot;
  
	- Seguran√ßa de Logins e gera√ß√£o de relat√≥rios atrav√©s do Spring Security;
  <br><br>
  
- **Oracle Cloud (AWS)**: 
  <br><br>
    Foi adotado um banco de dados na nuvem para sustentar os dados da aplica√ß√£o com conex√£o atrav√©s da Wallet Oracle;
  <br><br>
  
- **Maven**: 
  <br>  
    Utilizado para versionar e gerenciar as bibliotecas, facilitando que todos os desenvolvedores e usu√°rios utilizem o c√≥digo mais atualizado no momento, principalmente na manuten√ß√£o de bibliotecas Java utilizadas, algo que durante o processo e na instala√ß√£o do c√≥digo final simplifica o uso do mesmo;
  <br><br>

- **Docker/Docker Compose**:
  <br><br>
    Docker foi utilizado para containerizar toda a aplica√ß√£o, garantindo consist√™ncia entre os ambientes de desenvolvimento, teste e produ√ß√£o. Docker Compose foi empregado para gerenciar setups de m√∫ltiplos containers, facilitando a implanta√ß√£o e garantindo que os ambientes sejam mantidos de forma consistente ao longo do ciclo de vida do projeto.
  <br><br>

<h5>Frontend: </h5>

- **Vue.js**: 
  <br>
    Todo o visual e design da p√°gina web foram feitos utilizando essa tecnologia, incluindo os relat√≥rios e a cria√ß√£o de laudos;
  <br><br>
  
- **TypeScript**:
  <br>
    L√≥gica das p√°ginas, incluindo restri√ß√µes, preenchimentos e filtragem dos dados selecionados pelos usu√°rios, conectando e utilizando as APIs criadas em Java/Spring Boot;
  <br>

<h4>Contribui√ß√µes Individuais</h4>

<details>
<summary>Backend</summary>
  <details>
<summary>API Rest</summary>
  
- Usando Spring Boot, criei as APIs a serem consumidas, tanto as de cria√ß√£o dos laudos quanto as de sele√ß√£o de valores dos clientes e seus laudos j√° registrados.

Exemplo:

<pre><code>
@RestController
@RequestMapping(value = "/setor")
public class SetorController {
    @Autowired
    private ISetorService service;

    @GetMapping
    public List<Setor> buscarTodosSetores() {
        return service.buscarTodosSetores();
    }

    @PostMapping
    public Setor novoSetor(@RequestBody Setor setor) {
        return service.novoSetor(setor);
    }

    @GetMapping(value = "/{setor}")
    public Setor buscarPorId(@PathVariable("setor") Long id) {
        return service.buscarPorId(id);
    }
}
</code></pre>

Neste exemplo, utilizei m√©todos GET e POST para receber os dados vindos do frontend. Como o frontend envia os dados em formato JSON, o Vue.js envia seus objetos e atributos de acordo com o banco, assim como est√£o feitas as entidades no backend. No caso do m√©todo `GET /setor/{setor}`, um objeto do tipo Setor est√° sendo recebido pela API, utilizando o par√¢metro ID para a pesquisa presente no service utilizado (buscar o registro com o ID em espec√≠fico). J√° o m√©todo `POST /setor` √© utilizado para receber o objeto Setor com os par√¢metros inseridos no frontend, com o intuito de criar um novo registro de setor. O m√©todo `GET /setor` seleciona todos os registros de setores.
  </details>
</details>

<details>
<summary>Frontend</summary>
  <details>
	<summary>Requisi√ß√£o das APIs Rest</summary>
	
Exemplo de requisi√ß√£o Rest que consome a API do backend Spring Boot:

<pre><code>
// Fun√ß√£o para buscar os setores do banco
async function buscarSetor() {
    try {
        const response = await axios.get('setor');
        SelectionSection.value = response.data;
    } catch (error) {
        console.error('Error fetching servico:', error);
    }  
}
</code></pre>

Nessa fun√ß√£o estou consumindo a rota `'/setor'` que retorna um objeto com a lista de setores cadastrados.
  </details>

<details> 
		<summary>Vue.js</summary>
		
Exemplo de uso da requisi√ß√£o no Vue.js:
```
<label>Setor: </label>
<select class="setor" id="setor" v-model="setor" @change="getSetor()">
    <option v-for="s in setores" :key="s.id" v-bind:value="s.id">{{ s.nome }}</option>
</select>
```

Utilizando o framework Vue.js, foi poss√≠vel armazenar a lista de setores para que fossem visualizados na view do projeto utilizando o `v-model`. No caso de uso acima, aparecem os setores para serem selecionados dentro de um HTML select. Ao selecionar atrav√©s da anota√ß√£o `@change`, o ID do setor em quest√£o √© salvo para atualizar o registro no banco de dados.
	</details>
</details>

<br>

<h3> Resultado/Aplica√ß√£o: <h3>
	
![image](https://github.com/user-attachments/assets/8796f280-f6d8-447d-a208-ee9f5eb530a4)

<br>

 
<h4>Aprendizado Efetivo:</h4>

<summary>Requisi√ß√£o Rests:</summary>
- Como consumir e utilizar uma API Rest atrav√©s do envio de um corpo de requisi√ß√£o adequado e como utilizar as respostas foi um dos principais aprendizados;
<br><br>
<summary>Vue.js:</summary>
- O framework possibilitou o uso de routers, ou seja, dentro da mesma view √© poss√≠vel adicionar m√∫ltiplas interfaces para o usu√°rio;
- O uso de constantes diretamente no HTML atrav√©s do v-model;
<br><br>
<summary>Conex√£o de banco de dados atrav√©s de Wallet AWS:</summary>
- Utilizamos uma wallet AWS no reposit√≥rio para que, sem configura√ß√µes extensas no application properties, a conex√£o com o banco de dados fosse poss√≠vel em qualquer m√°quina que a possu√≠sse.
<br><br>
<summary>Spring Security: </summary>
- Utilizando o security, valida√ß√µes de n√≠vel de usu√°rio na aplica√ß√£o foi poss√≠vel ao adicionar a senha criptografada em hash e separando os usu√°rios por n√≠vel de acesso.
<br><br>
<summary>Spring e JPA: </summary>
- A fun√ß√£o save() funciona tanto para o Insert quanto para um Update, ou seja, um objeto que n√£o existe n√£o vai ter ID, logo √© um novo registro. Agora um objeto com um ID existente substituir√° os valores registrados no banco pelos atributos que ele cont√©m, se baseando no ID para realizar o update (where do update √© o pr√≥prio ID do objeto em quest√£o), isso √© feito automaticamente na fun√ß√£o save() do Spring.

## Conclus√£o

O projeto desenvolvido em parceria com a JAIA resultou em um sistema eficaz para gerenciar inspe√ß√µes prediais e manuten√ß√µes. Utilizando tecnologias como Java, Spring Boot, e Vue.js, criamos uma API robusta e uma interface intuitiva que atende √†s necessidades do cliente.

As funcionalidades implementadas garantem uma navega√ß√£o simples e a manipula√ß√£o √°gil de dados, promovendo seguran√ßa e efici√™ncia na gest√£o de patrim√¥nios. Assim, o sistema n√£o s√≥ atende aos requisitos, mas tamb√©m estabelece uma base s√≥lida para futuras melhorias.

<!-- Links para navega√ß√£o -->
<a href="#topo">Voltar ao topo</a>

<br>

<div id="portfolio5Tecsus">
	<h1> Projeto API com o Parceiro Acad√™mico TecSUS (2024-1) </h1>
</div>

[Link para Reposit√≥rio do Projeto](https://github.com/quarks-team/Projeto-Integrador-TecSUS)

## Objetivo

O principal objetivo deste projeto foi desenvolver um **Dashboard Web** de alta complexidade, capaz de processar e analisar faturas de energia e √°gua de diversas unidades de clientes. O sistema permite que as empresas identifiquem oportunidades de redu√ß√£o de custos e otimiza√ß√£o de contratos com concession√°rias. Al√©m disso, o dashboard oferece funcionalidades de gera√ß√£o de relat√≥rios detalhados e alertas com base no consumo, possibilitando uma vis√£o clara sobre o desempenho e os custos de cada unidade ou contrato.

## Tecnologias Utilizadas

- **Node.js**: 
  - Utilizado para construir uma API backend escal√°vel, o Node.js permite o manuseio de m√∫ltiplas requisi√ß√µes simultaneamente, tornando-o ideal para processamento de dados em tempo real e intera√ß√£o com o frontend.

- **MySQL**: 
  - Um sistema de gerenciamento de banco de dados relacional escolhido por sua robustez e efici√™ncia em armazenar e consultar dados estruturados, garantindo integridade dos dados e facilitando consultas complexas.

- **Vue.js**: 
  - Empregado como o framework frontend para criar uma interface de usu√°rio din√¢mica e responsiva. O Vue.js oferece uma arquitetura baseada em componentes que melhora a reutiliza√ß√£o de c√≥digo e simplifica o processo de desenvolvimento.

- **Docker/Docker Compose**: 
  - Usado para containerizar a aplica√ß√£o, garantindo um ambiente de desenvolvimento e produ√ß√£o consistente. O Docker simplifica o gerenciamento de depend√™ncias e a implanta√ß√£o da aplica√ß√£o, permitindo uma integra√ß√£o e escalabilidade cont√≠nuas.

- **Railway**: 
  - Escolhido para o deploy da aplica√ß√£o, o Railway permite uma implementa√ß√£o r√°pida e eficiente em ambientes de produ√ß√£o. Oferece automa√ß√£o de CI/CD, facilitando o gerenciamento de deploys e garantindo a disponibilidade cont√≠nua do sistema.

- **Power BI**: 
  - Integrado para visualiza√ß√£o e relat√≥rios de dados. O Power BI permite a cria√ß√£o de dashboards interativos que ajudam os stakeholders a tomar decis√µes informadas com base em insights de dados em tempo real.

- **TypeScript**: 
  - Adotado para aprimorar o JavaScript com tipagem est√°tica, melhorando a qualidade e a manutenibilidade do c√≥digo. O TypeScript permite uma melhor ferramenta e detec√ß√£o de erros durante o desenvolvimento, contribuindo para uma aplica√ß√£o mais robusta.


## Minhas Contribui√ß√µes

### Modelagem Dimensional
- Participei da modelagem dimensional, criando um banco de dados que facilitou a an√°lise de grandes volumes de dados. Essa arquitetura permitiu gerar relat√≥rios r√°pidos e eficientes, essenciais para lidar com m√∫ltiplas faturas por unidade, contrato e concession√°ria, sem comprometer a performance.
- Atuei em todas as fases da modelagem: concep√ß√£o inicial, constru√ß√£o e implementa√ß√£o das tabelas de fato e dimens√£o. Trabalhei na defini√ß√£o de como as tabelas se relacionariam, levando em conta as especificidades dos dados de energia e √°gua. Tamb√©m desenvolvi as queries para carga de dados nas tabelas de fato, garantindo integridade e efici√™ncia durante o processo de ETL.

<details>
<summary>Modelagem Dimensional</summary>
<img src="https://github.com/quarks-team/Projeto-Integrador-TecSUS-Database/blob/main/modelagem_banco_API_v.06.png">
</details>

### Backend com Node.js
Neste exemplo, desenvolvi um **controller** em Node.js que permitiu ao usu√°rio carregar seus arquivos atrav√©s do frontend e acompanhar o progresso do upload e do processo de ETL. Como o carregamento dos arquivos podia demorar at√© 5 minutos, era essencial manter o usu√°rio informado sobre o tempo restante para a conclus√£o da carga.

<details>
<summary>Exemplo de Controller em Node.js</summary>
<pre><code>
@Controller('billing')
export class BillingController {
  constructor(private readonly service: BillingService) {}

  @Post('upload')
  @UseInterceptors(FilesInterceptor('files'))
  async uploadFiles(@UploadedFiles() files: Express.Multer.File[]) {
    const folderPath = path.join(__dirname, 'files');
    await mkdir(folderPath, { recursive: true });
    const filePromises = files.map(async (file) => {
      const filePath = path.join(folderPath, file.originalname);
      await writeFile(filePath, file.buffer);
      const log = (message: string) => {
        if (global.sseResponse) {
          global.sseResponse.write(
            `event: user-log\ndata: ${JSON.stringify({ message })}\n\n`,
          );
        }
      };
      await this.service.transform(file.originalname, filePath, log);
      if (global.sseResponse) {
        global.sseResponse.write(
          `event: user-log\ndata: ${JSON.stringify({
            message: \`O arquivo "\${file.originalname}" foi processado com sucesso.\`,
          })}\n\n`,
        );
      }
    });
    await Promise.all(filePromises);
    if (global.sseResponse) {
      global.sseResponse.write(
        `event: user-log\ndata: ${JSON.stringify({
          message: 'Todos os arquivos foram processados com sucesso.',
        })}\n\n`,
      );
      global.sseResponse.end();
    }
    return { message: 'Todos os arquivos foram processados com sucesso.' };
  }
}
</code></pre>
</details>

### ETL com Node.js
Implementei a l√≥gica de **ETL** (Extra√ß√£o, Transforma√ß√£o e Carga) para inserir dados nas tabelas, verificando quais arquivos o usu√°rio carregou e processando-os adequadamente. O sistema verificava se os dados carregados pertenciam a contratos ou contas de √°gua ou energia, e s√≥ realizava a carga nas respectivas tabelas fato, garantindo a integridade e a coer√™ncia dos dados.

<details>
<summary>Exemplo de Transforma√ß√£o e Carga de Dados</summary>
<pre><code>
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, In } from 'typeorm';
import { Time } from '../entity/time.entity';
import { WatterBill } from '../entity/watter-bill.entity';
import { WatterBillPayload } from '../request/watter-bill-payload';

export class IngestWatterBill {
  constructor(
    @InjectRepository(Time) private readonly timeRepo: Repository<Time>,
    @InjectRepository(WatterBill)
    private readonly billRepo: Repository<WatterBill>,
  ) {}

  async execute(watterBills: WatterBillPayload[]) {
    const times: Partial<Time>[] = [];
    const bills: Partial<WatterBill>[] = [];
    watterBills.forEach((bill) => {
      const [day, month, year] = bill['Conta do M√™s'].split('/').map(Number);
      const billDate = new Date(year, month - 1, day);
      bills.push({
        rgiCode: bill['C√≥digo de Liga√ß√£o (RGI)'],
        billDate: billDate,
        hidrometer: bill.Hidr√¥metro,
        watterConsume: Number.parseFloat(
          bill['Consumo de √Ågua m¬≥'].replace(',', ''),
        ),
        wastePipeConsume: Number.parseFloat(
          bill['Consumo de Esgoto m¬≥'].replace(',', ''),
        ),
        watterValue: Number.parseFloat(bill['Valor √Ågua R$'].replace(',', '')),
        wastePipeValue: Number.parseFloat(
          bill['Valor Esgoto R$'].replace(',', ''),
        ),
        total: Number.parseFloat(bill['Total R$'].replace(',', '')),
        plant: bill.Planta,
        provider: 'null',
      });
      times.push({
        month: month.toString(),
        year: year.toString(),
      });
    });
    // Processa dados, verifica duplicidade e insere dados nas tabelas de tempo e conta
    // Carga nas tabelas de fato ocorre somente ap√≥s verifica√ß√µes necess√°rias
    try {
      const distinctTimes = this.getDistinctObjects(times);
      const existingTimes = await this.timeRepo.find({
        where: {
          month: In(distinctTimes.map((time) => time.month)),
          year: In(distinctTimes.map((time) => time.year)),
        },
      });
      const newTimes = distinctTimes.filter(
        (time) => !existingTimes.find((existing) => existing.month === time.month && existing.year === time.year),
      );
      await this.timeRepo.save(newTimes);
    } catch (error) {
      console.error('Error saving times:', error);
    }
  }

  // Fun√ß√£o auxiliar para remover duplicidade de objetos
  getDistinctObjects(array) {
    return array.filter(
      (obj, index, self) =>
        index ===
        self.findIndex((t) => t.month === obj.month && t.year === obj.year),
    );
  }
}
</code></pre>
</details>

### Verifica√ß√£o e Carga nas Tabelas Fato
Ap√≥s as transforma√ß√µes, o processo de carga nas tabelas fato de √°gua ou energia era executado. A carga s√≥ ocorria se houvesse novos dados relevantes, garantindo efici√™ncia e evitando duplicidades.

<details>
<summary>Carga nas Tabelas Fato</summary>
<pre><code>
async execute() {
  const hasSomeContract = await this.contractRepo.count();
  const hasSomeBill = await this.billRepo.count();
  if (hasSomeBill > 0 && hasSomeContract > 0) {
    await this.factRepo.clear();
    await this.factRepo.query(
      `INSERT INTO fato_conta_agua (
        contrato_agua_id,
        conta_agua_id,
        unidade_cliente_id,
        tempo_id,
        local_planta_id,
        total_conta_agua,
        total_consumo_agua,
        total_consumo_esgoto,
        total_valor_agua,
        total_valor_esgoto
      )
      SELECT 
        c.contrato_agua_id, 
        conta.conta_agua_id, 
        u.unidade_cliente_id, 
        t.tempo_id, 
        l.local_planta_id,
        SUM(conta.total_conta_agua) AS total_conta_agua, 
        SUM(conta.consumo_agua) AS total_consumo_agua,
        SUM(conta.consumo_esgoto) AS total_consumo_esgoto, 
        SUM(conta.valor_agua) AS total_valor_agua, 
        SUM(conta.valor_esgoto) AS total_valor_esgoto
      FROM conta_agua conta
      INNER JOIN contrato_agua c ON conta.codigo_rgi = c.codigo_rgi
      INNER JOIN unidade_cliente u ON c.cnpj = u.cnpj
      INNER JOIN local_planta l ON l.planta = conta.planta_agua
      INNER JOIN tempo t ON t.tempo_mes = DATE_FORMAT(conta.agua_conta_mes, '%m') 
                          AND t.tempo_ano = DATE_FORMAT(conta.agua_conta_mes, '%Y')
      GROUP BY c.contrato_agua_id, conta.conta_agua_id, u.unidade_cliente_id, t.tempo_id, l.local_planta_id;`
    );
  }
}
</code></pre>
</details>

### Estrat√©gia de Branches e Rastreabilide de requisitos

A estrat√©gia de **Trunk-Based Development** foi implementada para garantir que toda a equipe trabalhasse a partir da vers√£o mais atualizada do c√≥digo. Com isso, todas as novas funcionalidades e corre√ß√µes eram desenvolvidas a partir de uma branch clonada da main, permitindo uma colabora√ß√£o mais fluida entre os membros do time.

Essa abordagem n√£o apenas assegurou que todos os desenvolvedores estivessem alinhados com a √∫ltima vers√£o do c√≥digo, mas tamb√©m facilitou a identifica√ß√£o dos requisitos sendo abordados em cada tarefa. Cada branch criada inclu√≠a o ID da task, permitindo relacion√°-la diretamente √† User Story correspondente, a qual descrevia quais requisitos seriam atendidos. Dessa forma, a equipe conseguiu acompanhar o progresso e a implementa√ß√£o dos requisitos de forma clara e organizada, garantindo um fluxo de trabalho eficiente e a entrega de solu√ß√µes alinhadas √†s necessidades do projeto.

<br>

<h3> Resultado/Aplica√ß√£o: <h3>
	
<img src="https://github.com/quarks-team/Projeto-Integrador-TecSUS/blob/main/Documents/Gifs/gif-dash-agua.gif">

<br>

## Aprendizado Efetivo

Durante o desenvolvimento deste projeto, aprendi muito sobre v√°rias √°reas fundamentais da constru√ß√£o de sistemas complexos, como:

### Modelagem Dimensional
- Trabalhei intensamente com modelagem dimensional, essencial para lidar com grandes volumes de dados e para garantir relat√≥rios √°geis.

### Node.js
- O uso de Node.js em backends escal√°veis foi vantajoso tanto pela performance quanto pela facilidade de integra√ß√£o com bibliotecas de processamento de dados.

### SQL e Consultas Otimizadas
- A otimiza√ß√£o de queries para grandes bases de dados, principalmente aquelas relacionadas ao c√°lculo de m√©tricas e agrega√ß√µes, foi crucial para manter a efici√™ncia do sistema.

### DevOps
- Aprendi sobre os princ√≠pios e pr√°ticas do DevOps, que enfatizam a colabora√ß√£o entre as equipes de desenvolvimento e opera√ß√µes para automatizar e melhorar o ciclo de vida do desenvolvimento de software. A implementa√ß√£o de uma esteira DevOps permitiu integrar testes automatizados, integra√ß√£o cont√≠nua e entrega cont√≠nua (CI/CD), garantindo que as atualiza√ß√µes e implementa√ß√µes fossem mais r√°pidas, seguras e confi√°veis. Isso n√£o apenas melhorou a qualidade do c√≥digo, mas tamb√©m aumentou a efici√™ncia do processo de desenvolvimento como um todo.


### Conclus√£o

Este projeto foi uma grande oportunidade para expandir minhas habilidades como desenvolvedor, especialmente ao trabalhar com tecnologias novas para mim, como Node.js e modelagem dimensional. O uso de Node.js no backend permitiu criar APIs eficientes e escal√°veis, o que me proporcionou um aprendizado valioso em uma stack que eu ainda n√£o dominava. Al√©m disso, a modelagem dimensional aprimorou minha capacidade de organizar e estruturar dados para an√°lises mais poderosas, otimizando o desempenho de visualiza√ß√µes no Power BI.

A implementa√ß√£o de uma esteira de DevOps garantiu um ciclo de desenvolvimento cont√≠nuo e rastre√°vel, permitindo um processo √°gil e confi√°vel. No final, o sistema desenvolvido oferece insights importantes para o cliente, melhorando a gest√£o de contratos e a tomada de decis√µes estrat√©gicas. O projeto me transformou em um desenvolvedor mais completo, integrando habilidades de backend, ETL e visualiza√ß√£o de dados em um √∫nico ecossistema eficiente e bem estruturado.

<!-- Links para navega√ß√£o -->
<a href="#topo">Voltar ao topo</a>

<br>

<div id="portfolio6SpcGrafeno">
	<h1>Em 2024-2 foi trabalhado um projeto API com o parceiro acad√™mico SPC Grafeno</h1>
	* [Link para Reposit√≥rio do Projeto](https://github.com/quarks-team/Projeto-Integrador-SPCGrafeno)
 	<h2> LOADING .... </h2>
</div>
